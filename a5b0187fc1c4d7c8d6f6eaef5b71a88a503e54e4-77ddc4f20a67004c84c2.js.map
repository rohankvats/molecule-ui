{"version":3,"sources":["webpack:///./node_modules/fuzzaldrin-plus/lib/scorer.js","webpack:///./node_modules/fuzzaldrin-plus/lib/pathScorer.js","webpack:///./node_modules/fuzzaldrin-plus/lib/query.js","webpack:///./node_modules/fuzzaldrin-plus/lib/filter.js","webpack:///./node_modules/fuzzaldrin-plus/lib/matcher.js","webpack:///./node_modules/fuzzaldrin-plus/lib/fuzzaldrin.js"],"names":["AcronymResult","computeScore","emptyAcronymResult","isAcronymFullWord","isMatch","isSeparator","isWordEnd","isWordStart","scoreAcronyms","scoreCharacter","scoreConsecutives","scoreExact","scoreExactMatch","scorePattern","scorePosition","scoreSize","exports","score","string","query","options","preparedQuery","string_lw","allowErrors","core_lw","core_up","toLowerCase","Math","ceil","subject","query_lw","query_up","i","j","m","n","qj_lw","qj_up","si","length","charCodeAt","subject_lw","acro","acro_score","align","csc_diag","csc_row","csc_score","csc_should_rebuild","miss_budget","miss_left","pos","record_miss","score_diag","score_row","score_up","si_lw","start","sz","count","indexOf","Array","charCodes","max","curr_s","prev_s","len","next_s","c","sc","abs","quality","sameCase","end","bonus","posBonus","startOfWord","k","mi","nj","pos2","this","fullWord","sepCount","sumPos","nbAcronymInQuery","call","countDir","_getExtensionScore","scorePath","_ref","fullPathScore","alpha","basePathScore","basePos","depth","extAdjust","fileLength","pathSeparator","useExtensionBonus","lastIndexOf","ext","slice","path","getExtension","str","substr","candidate","startPos","endPos","maxDepth","matched","coreChars","getCharCodes","opt_char_re","truncatedUpperCase","module","_arg","optCharRegEx","_ref1","core","replace","upper","_i","_len","toUpperCase","pathScorer","pluckCandidates","scorer","sortCandidates","a","b","candidates","bKey","key","maxInners","maxResults","scoreProvider","scoredCandidates","spotLeft","usePathScoring","push","sort","map","basenameMatch","computeMatch","match","mergeMatches","baseMatches","matches","wrap","matchIndex","matchPos","matchPositions","output","strPos","tagClass","tagClose","tagOpen","substring","ai","bj","out","offset","backtrack","move","trace","reverse","Query","defaultPathSeparator","_filter","matcher","parseOptions","preparedQueryCache","process","platform","filter","_results","apply","prepareQuery"],"mappings":"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","file":"a5b0187fc1c4d7c8d6f6eaef5b71a88a503e54e4-77ddc4f20a67004c84c2.js","sourcesContent":["(function () {\n  var AcronymResult, computeScore, emptyAcronymResult, isAcronymFullWord, isMatch, isSeparator, isWordEnd, isWordStart, miss_coeff, pos_bonus, scoreAcronyms, scoreCharacter, scoreConsecutives, scoreExact, scoreExactMatch, scorePattern, scorePosition, scoreSize, tau_size, wm;\n  wm = 150;\n  pos_bonus = 20;\n  tau_size = 150;\n  miss_coeff = 0.75;\n\n  exports.score = function (string, query, options) {\n    var allowErrors, preparedQuery, score, string_lw;\n    preparedQuery = options.preparedQuery, allowErrors = options.allowErrors;\n\n    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {\n      return 0;\n    }\n\n    string_lw = string.toLowerCase();\n    score = computeScore(string, string_lw, preparedQuery);\n    return Math.ceil(score);\n  };\n\n  exports.isMatch = isMatch = function isMatch(subject, query_lw, query_up) {\n    var i, j, m, n, qj_lw, qj_up, si;\n    m = subject.length;\n    n = query_lw.length;\n\n    if (!m || n > m) {\n      return false;\n    }\n\n    i = -1;\n    j = -1;\n\n    while (++j < n) {\n      qj_lw = query_lw.charCodeAt(j);\n      qj_up = query_up.charCodeAt(j);\n\n      while (++i < m) {\n        si = subject.charCodeAt(i);\n\n        if (si === qj_lw || si === qj_up) {\n          break;\n        }\n      }\n\n      if (i === m) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  exports.computeScore = computeScore = function computeScore(subject, subject_lw, preparedQuery) {\n    var acro, acro_score, align, csc_diag, csc_row, csc_score, csc_should_rebuild, i, j, m, miss_budget, miss_left, n, pos, query, query_lw, record_miss, score, score_diag, score_row, score_up, si_lw, start, sz;\n    query = preparedQuery.query;\n    query_lw = preparedQuery.query_lw;\n    m = subject.length;\n    n = query.length;\n    acro = scoreAcronyms(subject, subject_lw, query, query_lw);\n    acro_score = acro.score;\n\n    if (acro.count === n) {\n      return scoreExact(n, m, acro_score, acro.pos);\n    }\n\n    pos = subject_lw.indexOf(query_lw);\n\n    if (pos > -1) {\n      return scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m);\n    }\n\n    score_row = new Array(n);\n    csc_row = new Array(n);\n    sz = scoreSize(n, m);\n    miss_budget = Math.ceil(miss_coeff * n) + 5;\n    miss_left = miss_budget;\n    csc_should_rebuild = true;\n    j = -1;\n\n    while (++j < n) {\n      score_row[j] = 0;\n      csc_row[j] = 0;\n    }\n\n    i = -1;\n\n    while (++i < m) {\n      si_lw = subject_lw[i];\n\n      if (!si_lw.charCodeAt(0) in preparedQuery.charCodes) {\n        if (csc_should_rebuild) {\n          j = -1;\n\n          while (++j < n) {\n            csc_row[j] = 0;\n          }\n\n          csc_should_rebuild = false;\n        }\n\n        continue;\n      }\n\n      score = 0;\n      score_diag = 0;\n      csc_diag = 0;\n      record_miss = true;\n      csc_should_rebuild = true;\n      j = -1;\n\n      while (++j < n) {\n        score_up = score_row[j];\n\n        if (score_up > score) {\n          score = score_up;\n        }\n\n        csc_score = 0;\n\n        if (query_lw[j] === si_lw) {\n          start = isWordStart(i, subject, subject_lw);\n          csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);\n          align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);\n\n          if (align > score) {\n            score = align;\n            miss_left = miss_budget;\n          } else {\n            if (record_miss && --miss_left <= 0) {\n              return Math.max(score, score_row[n - 1]) * sz;\n            }\n\n            record_miss = false;\n          }\n        }\n\n        score_diag = score_up;\n        csc_diag = csc_row[j];\n        csc_row[j] = csc_score;\n        score_row[j] = score;\n      }\n    }\n\n    score = score_row[n - 1];\n    return score * sz;\n  };\n\n  exports.isWordStart = isWordStart = function isWordStart(pos, subject, subject_lw) {\n    var curr_s, prev_s;\n\n    if (pos === 0) {\n      return true;\n    }\n\n    curr_s = subject[pos];\n    prev_s = subject[pos - 1];\n    return isSeparator(prev_s) || curr_s !== subject_lw[pos] && prev_s === subject_lw[pos - 1];\n  };\n\n  exports.isWordEnd = isWordEnd = function isWordEnd(pos, subject, subject_lw, len) {\n    var curr_s, next_s;\n\n    if (pos === len - 1) {\n      return true;\n    }\n\n    curr_s = subject[pos];\n    next_s = subject[pos + 1];\n    return isSeparator(next_s) || curr_s === subject_lw[pos] && next_s !== subject_lw[pos + 1];\n  };\n\n  isSeparator = function isSeparator(c) {\n    return c === ' ' || c === '.' || c === '-' || c === '_' || c === '/' || c === '\\\\';\n  };\n\n  scorePosition = function scorePosition(pos) {\n    var sc;\n\n    if (pos < pos_bonus) {\n      sc = pos_bonus - pos;\n      return 100 + sc * sc;\n    } else {\n      return Math.max(100 + pos_bonus - pos, 0);\n    }\n  };\n\n  exports.scoreSize = scoreSize = function scoreSize(n, m) {\n    return tau_size / (tau_size + Math.abs(m - n));\n  };\n\n  scoreExact = function scoreExact(n, m, quality, pos) {\n    return 2 * n * (wm * quality + scorePosition(pos)) * scoreSize(n, m);\n  };\n\n  exports.scorePattern = scorePattern = function scorePattern(count, len, sameCase, start, end) {\n    var bonus, sz;\n    sz = count;\n    bonus = 6;\n\n    if (sameCase === count) {\n      bonus += 2;\n    }\n\n    if (start) {\n      bonus += 3;\n    }\n\n    if (end) {\n      bonus += 1;\n    }\n\n    if (count === len) {\n      if (start) {\n        if (sameCase === len) {\n          sz += 2;\n        } else {\n          sz += 1;\n        }\n      }\n\n      if (end) {\n        bonus += 1;\n      }\n    }\n\n    return sameCase + sz * (sz + bonus);\n  };\n\n  exports.scoreCharacter = scoreCharacter = function scoreCharacter(i, j, start, acro_score, csc_score) {\n    var posBonus;\n    posBonus = scorePosition(i);\n\n    if (start) {\n      return posBonus + wm * ((acro_score > csc_score ? acro_score : csc_score) + 10);\n    }\n\n    return posBonus + wm * csc_score;\n  };\n\n  exports.scoreConsecutives = scoreConsecutives = function scoreConsecutives(subject, subject_lw, query, query_lw, i, j, startOfWord) {\n    var k, m, mi, n, nj, sameCase, sz;\n    m = subject.length;\n    n = query.length;\n    mi = m - i;\n    nj = n - j;\n    k = mi < nj ? mi : nj;\n    sameCase = 0;\n    sz = 0;\n\n    if (query[j] === subject[i]) {\n      sameCase++;\n    }\n\n    while (++sz < k && query_lw[++j] === subject_lw[++i]) {\n      if (query[j] === subject[i]) {\n        sameCase++;\n      }\n    }\n\n    if (sz < k) {\n      i--;\n    }\n\n    if (sz === 1) {\n      return 1 + 2 * sameCase;\n    }\n\n    return scorePattern(sz, n, sameCase, startOfWord, isWordEnd(i, subject, subject_lw, m));\n  };\n\n  exports.scoreExactMatch = scoreExactMatch = function scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m) {\n    var end, i, pos2, sameCase, start;\n    start = isWordStart(pos, subject, subject_lw);\n\n    if (!start) {\n      pos2 = subject_lw.indexOf(query_lw, pos + 1);\n\n      if (pos2 > -1) {\n        start = isWordStart(pos2, subject, subject_lw);\n\n        if (start) {\n          pos = pos2;\n        }\n      }\n    }\n\n    i = -1;\n    sameCase = 0;\n\n    while (++i < n) {\n      if (query[pos + i] === subject[i]) {\n        sameCase++;\n      }\n    }\n\n    end = isWordEnd(pos + n - 1, subject, subject_lw, m);\n    return scoreExact(n, m, scorePattern(n, n, sameCase, start, end), pos);\n  };\n\n  AcronymResult = function () {\n    function AcronymResult(score, pos, count) {\n      this.score = score;\n      this.pos = pos;\n      this.count = count;\n    }\n\n    return AcronymResult;\n  }();\n\n  emptyAcronymResult = new AcronymResult(0, 0.1, 0);\n\n  exports.scoreAcronyms = scoreAcronyms = function scoreAcronyms(subject, subject_lw, query, query_lw) {\n    var count, fullWord, i, j, m, n, qj_lw, sameCase, score, sepCount, sumPos;\n    m = subject.length;\n    n = query.length;\n\n    if (!(m > 1 && n > 1)) {\n      return emptyAcronymResult;\n    }\n\n    count = 0;\n    sepCount = 0;\n    sumPos = 0;\n    sameCase = 0;\n    i = -1;\n    j = -1;\n\n    while (++j < n) {\n      qj_lw = query_lw[j];\n\n      if (isSeparator(qj_lw)) {\n        i = subject_lw.indexOf(qj_lw, i + 1);\n\n        if (i > -1) {\n          sepCount++;\n          continue;\n        } else {\n          break;\n        }\n      }\n\n      while (++i < m) {\n        if (qj_lw === subject_lw[i] && isWordStart(i, subject, subject_lw)) {\n          if (query[j] === subject[i]) {\n            sameCase++;\n          }\n\n          sumPos += i;\n          count++;\n          break;\n        }\n      }\n\n      if (i === m) {\n        break;\n      }\n    }\n\n    if (count < 2) {\n      return emptyAcronymResult;\n    }\n\n    fullWord = count === n ? isAcronymFullWord(subject, subject_lw, query, count) : false;\n    score = scorePattern(count, n, sameCase, true, fullWord);\n    return new AcronymResult(score, sumPos / count, count + sepCount);\n  };\n\n  isAcronymFullWord = function isAcronymFullWord(subject, subject_lw, query, nbAcronymInQuery) {\n    var count, i, m, n;\n    m = subject.length;\n    n = query.length;\n    count = 0;\n\n    if (m > 12 * n) {\n      return false;\n    }\n\n    i = -1;\n\n    while (++i < m) {\n      if (isWordStart(i, subject, subject_lw) && ++count > nbAcronymInQuery) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n}).call(this);","(function () {\n  var computeScore, countDir, file_coeff, getExtension, _getExtensionScore, isMatch, scorePath, scoreSize, tau_depth, _ref;\n\n  _ref = require('./scorer'), isMatch = _ref.isMatch, computeScore = _ref.computeScore, scoreSize = _ref.scoreSize;\n  tau_depth = 20;\n  file_coeff = 2.5;\n\n  exports.score = function (string, query, options) {\n    var allowErrors, preparedQuery, score, string_lw;\n    preparedQuery = options.preparedQuery, allowErrors = options.allowErrors;\n\n    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {\n      return 0;\n    }\n\n    string_lw = string.toLowerCase();\n    score = computeScore(string, string_lw, preparedQuery);\n    score = scorePath(string, string_lw, score, options);\n    return Math.ceil(score);\n  };\n\n  scorePath = function scorePath(subject, subject_lw, fullPathScore, options) {\n    var alpha, basePathScore, basePos, depth, end, extAdjust, fileLength, pathSeparator, preparedQuery, useExtensionBonus;\n\n    if (fullPathScore === 0) {\n      return 0;\n    }\n\n    preparedQuery = options.preparedQuery, useExtensionBonus = options.useExtensionBonus, pathSeparator = options.pathSeparator;\n    end = subject.length - 1;\n\n    while (subject[end] === pathSeparator) {\n      end--;\n    }\n\n    basePos = subject.lastIndexOf(pathSeparator, end);\n    fileLength = end - basePos;\n    extAdjust = 1.0;\n\n    if (useExtensionBonus) {\n      extAdjust += _getExtensionScore(subject_lw, preparedQuery.ext, basePos, end, 2);\n      fullPathScore *= extAdjust;\n    }\n\n    if (basePos === -1) {\n      return fullPathScore;\n    }\n\n    depth = preparedQuery.depth;\n\n    while (basePos > -1 && depth-- > 0) {\n      basePos = subject.lastIndexOf(pathSeparator, basePos - 1);\n    }\n\n    basePathScore = basePos === -1 ? fullPathScore : extAdjust * computeScore(subject.slice(basePos + 1, end + 1), subject_lw.slice(basePos + 1, end + 1), preparedQuery);\n    alpha = 0.5 * tau_depth / (tau_depth + countDir(subject, end + 1, pathSeparator));\n    return alpha * basePathScore + (1 - alpha) * fullPathScore * scoreSize(0, file_coeff * fileLength);\n  };\n\n  exports.countDir = countDir = function countDir(path, end, pathSeparator) {\n    var count, i;\n\n    if (end < 1) {\n      return 0;\n    }\n\n    count = 0;\n    i = -1;\n\n    while (++i < end && path[i] === pathSeparator) {\n      continue;\n    }\n\n    while (++i < end) {\n      if (path[i] === pathSeparator) {\n        count++;\n\n        while (++i < end && path[i] === pathSeparator) {\n          continue;\n        }\n      }\n    }\n\n    return count;\n  };\n\n  exports.getExtension = getExtension = function getExtension(str) {\n    var pos;\n    pos = str.lastIndexOf(\".\");\n\n    if (pos < 0) {\n      return \"\";\n    } else {\n      return str.substr(pos + 1);\n    }\n  };\n\n  _getExtensionScore = function getExtensionScore(candidate, ext, startPos, endPos, maxDepth) {\n    var m, matched, n, pos;\n\n    if (!ext.length) {\n      return 0;\n    }\n\n    pos = candidate.lastIndexOf(\".\", endPos);\n\n    if (!(pos > startPos)) {\n      return 0;\n    }\n\n    n = ext.length;\n    m = endPos - pos;\n\n    if (m < n) {\n      n = m;\n      m = ext.length;\n    }\n\n    pos++;\n    matched = -1;\n\n    while (++matched < n) {\n      if (candidate[pos + matched] !== ext[matched]) {\n        break;\n      }\n    }\n\n    if (matched === 0 && maxDepth > 0) {\n      return 0.9 * _getExtensionScore(candidate, ext, startPos, pos - 2, maxDepth - 1);\n    }\n\n    return matched / m;\n  };\n}).call(this);","(function () {\n  var Query, coreChars, countDir, getCharCodes, getExtension, opt_char_re, truncatedUpperCase, _ref;\n\n  _ref = require(\"./pathScorer\"), countDir = _ref.countDir, getExtension = _ref.getExtension;\n\n  module.exports = Query = function () {\n    function Query(query, _arg) {\n      var optCharRegEx, pathSeparator, _ref1;\n\n      _ref1 = _arg != null ? _arg : {}, optCharRegEx = _ref1.optCharRegEx, pathSeparator = _ref1.pathSeparator;\n\n      if (!(query && query.length)) {\n        return null;\n      }\n\n      this.query = query;\n      this.query_lw = query.toLowerCase();\n      this.core = coreChars(query, optCharRegEx);\n      this.core_lw = this.core.toLowerCase();\n      this.core_up = truncatedUpperCase(this.core);\n      this.depth = countDir(query, query.length, pathSeparator);\n      this.ext = getExtension(this.query_lw);\n      this.charCodes = getCharCodes(this.query_lw);\n    }\n\n    return Query;\n  }();\n\n  opt_char_re = /[ _\\-:\\/\\\\]/g;\n\n  coreChars = function coreChars(query, optCharRegEx) {\n    if (optCharRegEx == null) {\n      optCharRegEx = opt_char_re;\n    }\n\n    return query.replace(optCharRegEx, '');\n  };\n\n  truncatedUpperCase = function truncatedUpperCase(str) {\n    var char, upper, _i, _len;\n\n    upper = \"\";\n\n    for (_i = 0, _len = str.length; _i < _len; _i++) {\n      char = str[_i];\n      upper += char.toUpperCase()[0];\n    }\n\n    return upper;\n  };\n\n  getCharCodes = function getCharCodes(str) {\n    var charCodes, i, len;\n    len = str.length;\n    i = -1;\n    charCodes = [];\n\n    while (++i < len) {\n      charCodes[str.charCodeAt(i)] = true;\n    }\n\n    return charCodes;\n  };\n}).call(this);","(function () {\n  var Query, pathScorer, pluckCandidates, scorer, sortCandidates;\n  scorer = require('./scorer');\n  pathScorer = require('./pathScorer');\n  Query = require('./query');\n\n  pluckCandidates = function pluckCandidates(a) {\n    return a.candidate;\n  };\n\n  sortCandidates = function sortCandidates(a, b) {\n    return b.score - a.score;\n  };\n\n  module.exports = function (candidates, query, options) {\n    var bKey, candidate, key, maxInners, maxResults, score, scoreProvider, scoredCandidates, spotLeft, string, usePathScoring, _i, _len;\n\n    scoredCandidates = [];\n    key = options.key, maxResults = options.maxResults, maxInners = options.maxInners, usePathScoring = options.usePathScoring;\n    spotLeft = maxInners != null && maxInners > 0 ? maxInners : candidates.length + 1;\n    bKey = key != null;\n    scoreProvider = usePathScoring ? pathScorer : scorer;\n\n    for (_i = 0, _len = candidates.length; _i < _len; _i++) {\n      candidate = candidates[_i];\n      string = bKey ? candidate[key] : candidate;\n\n      if (!string) {\n        continue;\n      }\n\n      score = scoreProvider.score(string, query, options);\n\n      if (score > 0) {\n        scoredCandidates.push({\n          candidate: candidate,\n          score: score\n        });\n\n        if (! --spotLeft) {\n          break;\n        }\n      }\n    }\n\n    scoredCandidates.sort(sortCandidates);\n    candidates = scoredCandidates.map(pluckCandidates);\n\n    if (maxResults != null) {\n      candidates = candidates.slice(0, maxResults);\n    }\n\n    return candidates;\n  };\n}).call(this);","(function () {\n  var basenameMatch, computeMatch, isMatch, isWordStart, match, mergeMatches, scoreAcronyms, scoreCharacter, scoreConsecutives, _ref;\n\n  _ref = require('./scorer'), isMatch = _ref.isMatch, isWordStart = _ref.isWordStart, scoreConsecutives = _ref.scoreConsecutives, scoreCharacter = _ref.scoreCharacter, scoreAcronyms = _ref.scoreAcronyms;\n\n  exports.match = match = function match(string, query, options) {\n    var allowErrors, baseMatches, matches, pathSeparator, preparedQuery, string_lw;\n    allowErrors = options.allowErrors, preparedQuery = options.preparedQuery, pathSeparator = options.pathSeparator;\n\n    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {\n      return [];\n    }\n\n    string_lw = string.toLowerCase();\n    matches = computeMatch(string, string_lw, preparedQuery);\n\n    if (matches.length === 0) {\n      return matches;\n    }\n\n    if (string.indexOf(pathSeparator) > -1) {\n      baseMatches = basenameMatch(string, string_lw, preparedQuery, pathSeparator);\n      matches = mergeMatches(matches, baseMatches);\n    }\n\n    return matches;\n  };\n\n  exports.wrap = function (string, query, options) {\n    var matchIndex, matchPos, matchPositions, output, strPos, tagClass, tagClose, tagOpen, _ref1;\n\n    if (options.wrap != null) {\n      _ref1 = options.wrap, tagClass = _ref1.tagClass, tagOpen = _ref1.tagOpen, tagClose = _ref1.tagClose;\n    }\n\n    if (tagClass == null) {\n      tagClass = 'highlight';\n    }\n\n    if (tagOpen == null) {\n      tagOpen = '<strong class=\"' + tagClass + '\">';\n    }\n\n    if (tagClose == null) {\n      tagClose = '</strong>';\n    }\n\n    if (string === query) {\n      return tagOpen + string + tagClose;\n    }\n\n    matchPositions = match(string, query, options);\n\n    if (matchPositions.length === 0) {\n      return string;\n    }\n\n    output = '';\n    matchIndex = -1;\n    strPos = 0;\n\n    while (++matchIndex < matchPositions.length) {\n      matchPos = matchPositions[matchIndex];\n\n      if (matchPos > strPos) {\n        output += string.substring(strPos, matchPos);\n        strPos = matchPos;\n      }\n\n      while (++matchIndex < matchPositions.length) {\n        if (matchPositions[matchIndex] === matchPos + 1) {\n          matchPos++;\n        } else {\n          matchIndex--;\n          break;\n        }\n      }\n\n      matchPos++;\n\n      if (matchPos > strPos) {\n        output += tagOpen;\n        output += string.substring(strPos, matchPos);\n        output += tagClose;\n        strPos = matchPos;\n      }\n    }\n\n    if (strPos <= string.length - 1) {\n      output += string.substring(strPos);\n    }\n\n    return output;\n  };\n\n  basenameMatch = function basenameMatch(subject, subject_lw, preparedQuery, pathSeparator) {\n    var basePos, depth, end;\n    end = subject.length - 1;\n\n    while (subject[end] === pathSeparator) {\n      end--;\n    }\n\n    basePos = subject.lastIndexOf(pathSeparator, end);\n\n    if (basePos === -1) {\n      return [];\n    }\n\n    depth = preparedQuery.depth;\n\n    while (depth-- > 0) {\n      basePos = subject.lastIndexOf(pathSeparator, basePos - 1);\n\n      if (basePos === -1) {\n        return [];\n      }\n    }\n\n    basePos++;\n    end++;\n    return computeMatch(subject.slice(basePos, end), subject_lw.slice(basePos, end), preparedQuery, basePos);\n  };\n\n  mergeMatches = function mergeMatches(a, b) {\n    var ai, bj, i, j, m, n, out;\n    m = a.length;\n    n = b.length;\n\n    if (n === 0) {\n      return a.slice();\n    }\n\n    if (m === 0) {\n      return b.slice();\n    }\n\n    i = -1;\n    j = 0;\n    bj = b[j];\n    out = [];\n\n    while (++i < m) {\n      ai = a[i];\n\n      while (bj <= ai && ++j < n) {\n        if (bj < ai) {\n          out.push(bj);\n        }\n\n        bj = b[j];\n      }\n\n      out.push(ai);\n    }\n\n    while (j < n) {\n      out.push(b[j++]);\n    }\n\n    return out;\n  };\n\n  computeMatch = function computeMatch(subject, subject_lw, preparedQuery, offset) {\n    var DIAGONAL, LEFT, STOP, UP, acro_score, align, backtrack, csc_diag, csc_row, csc_score, i, j, m, matches, move, n, pos, query, query_lw, score, score_diag, score_row, score_up, si_lw, start, trace;\n\n    if (offset == null) {\n      offset = 0;\n    }\n\n    query = preparedQuery.query;\n    query_lw = preparedQuery.query_lw;\n    m = subject.length;\n    n = query.length;\n    acro_score = scoreAcronyms(subject, subject_lw, query, query_lw).score;\n    score_row = new Array(n);\n    csc_row = new Array(n);\n    STOP = 0;\n    UP = 1;\n    LEFT = 2;\n    DIAGONAL = 3;\n    trace = new Array(m * n);\n    pos = -1;\n    j = -1;\n\n    while (++j < n) {\n      score_row[j] = 0;\n      csc_row[j] = 0;\n    }\n\n    i = -1;\n\n    while (++i < m) {\n      score = 0;\n      score_up = 0;\n      csc_diag = 0;\n      si_lw = subject_lw[i];\n      j = -1;\n\n      while (++j < n) {\n        csc_score = 0;\n        align = 0;\n        score_diag = score_up;\n\n        if (query_lw[j] === si_lw) {\n          start = isWordStart(i, subject, subject_lw);\n          csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);\n          align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);\n        }\n\n        score_up = score_row[j];\n        csc_diag = csc_row[j];\n\n        if (score > score_up) {\n          move = LEFT;\n        } else {\n          score = score_up;\n          move = UP;\n        }\n\n        if (align > score) {\n          score = align;\n          move = DIAGONAL;\n        } else {\n          csc_score = 0;\n        }\n\n        score_row[j] = score;\n        csc_row[j] = csc_score;\n        trace[++pos] = score > 0 ? move : STOP;\n      }\n    }\n\n    i = m - 1;\n    j = n - 1;\n    pos = i * n + j;\n    backtrack = true;\n    matches = [];\n\n    while (backtrack && i >= 0 && j >= 0) {\n      switch (trace[pos]) {\n        case UP:\n          i--;\n          pos -= n;\n          break;\n\n        case LEFT:\n          j--;\n          pos--;\n          break;\n\n        case DIAGONAL:\n          matches.push(i + offset);\n          j--;\n          i--;\n          pos -= n + 1;\n          break;\n\n        default:\n          backtrack = false;\n      }\n    }\n\n    matches.reverse();\n    return matches;\n  };\n}).call(this);","(function () {\n  var Query, defaultPathSeparator, _filter, matcher, parseOptions, pathScorer, preparedQueryCache, scorer;\n\n  _filter = require('./filter');\n  matcher = require('./matcher');\n  scorer = require('./scorer');\n  pathScorer = require('./pathScorer');\n  Query = require('./query');\n  preparedQueryCache = null;\n  defaultPathSeparator = (typeof process !== \"undefined\" && process !== null ? process.platform : void 0) === \"win32\" ? '\\\\' : '/';\n  module.exports = {\n    filter: function filter(candidates, query, options) {\n      if (options == null) {\n        options = {};\n      }\n\n      if (!((query != null ? query.length : void 0) && (candidates != null ? candidates.length : void 0))) {\n        return [];\n      }\n\n      options = parseOptions(options, query);\n      return _filter(candidates, query, options);\n    },\n    score: function score(string, query, options) {\n      if (options == null) {\n        options = {};\n      }\n\n      if (!((string != null ? string.length : void 0) && (query != null ? query.length : void 0))) {\n        return 0;\n      }\n\n      options = parseOptions(options, query);\n\n      if (options.usePathScoring) {\n        return pathScorer.score(string, query, options);\n      } else {\n        return scorer.score(string, query, options);\n      }\n    },\n    match: function match(string, query, options) {\n      var _i, _ref, _results;\n\n      if (options == null) {\n        options = {};\n      }\n\n      if (!string) {\n        return [];\n      }\n\n      if (!query) {\n        return [];\n      }\n\n      if (string === query) {\n        return function () {\n          _results = [];\n\n          for (var _i = 0, _ref = string.length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--) {\n            _results.push(_i);\n          }\n\n          return _results;\n        }.apply(this);\n      }\n\n      options = parseOptions(options, query);\n      return matcher.match(string, query, options);\n    },\n    wrap: function wrap(string, query, options) {\n      if (options == null) {\n        options = {};\n      }\n\n      if (!string) {\n        return [];\n      }\n\n      if (!query) {\n        return [];\n      }\n\n      options = parseOptions(options, query);\n      return matcher.wrap(string, query, options);\n    },\n    prepareQuery: function prepareQuery(query, options) {\n      if (options == null) {\n        options = {};\n      }\n\n      options = parseOptions(options, query);\n      return options.preparedQuery;\n    }\n  };\n\n  parseOptions = function parseOptions(options, query) {\n    if (options.allowErrors == null) {\n      options.allowErrors = false;\n    }\n\n    if (options.usePathScoring == null) {\n      options.usePathScoring = true;\n    }\n\n    if (options.useExtensionBonus == null) {\n      options.useExtensionBonus = false;\n    }\n\n    if (options.pathSeparator == null) {\n      options.pathSeparator = defaultPathSeparator;\n    }\n\n    if (options.optCharRegEx == null) {\n      options.optCharRegEx = null;\n    }\n\n    if (options.wrap == null) {\n      options.wrap = null;\n    }\n\n    if (options.preparedQuery == null) {\n      options.preparedQuery = preparedQueryCache && preparedQueryCache.query === query ? preparedQueryCache : preparedQueryCache = new Query(query, options);\n    }\n\n    return options;\n  };\n}).call(this);"],"sourceRoot":""}